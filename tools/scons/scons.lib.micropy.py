# Adding # to the beginning of the path
# Makes the path relative to the top level script

import sys
import os
import re
import subprocess
from os import path


# Import the scons environment from the calling script
Import('env')

# Load tools if not already loaded
tools = ['General', 'Micropython']
for item in tools:
    if item not in env['TOOLS']:
        env.Tool(item, toolpath=['tools'])


env.SetDefault(PY_SRC='${TOP}/py')

# where py object files go (they have a name prefix to prevent filename clashes)
env.Replace(PY_BUILD='${BUILD}/py')

# where autogenerated header files go
env.Replace(HEADER_BUILD='${BUILD}/genhdr')

# some code is performance bottleneck and compiled with other optimization options
env.Replace(CSUPEROPT='-O3')

# this sets the config file for FatFs
env.AppendUnique(CFLAGS_MOD='-DFFCONF_H="' + "lib/oofatfs/ffconf.h" + '"')

# Generate micropython version header
tgt = env.Mpversion('${HEADER_BUILD}/mpversion.h', [])

# We add in the extension when passing to the scons builder
# So this can represent .c source files or .o object files

# py object files
env.Replace(PY_CORE_SRCS=
    env.AddPrefix('py/',
    env.Split("""
    mpstate
    nlr
    nlrx86
    nlrx64
    nlrthumb
    nlrxtensa
    nlrsetjmp
    malloc
    gc
    pystack
    qstr
    vstr
    mpprint
    unicode
    mpz
    reader
    lexer
    parse
    scope
    compile
    emitcommon
    emitbc
    asmbase
    asmx64
    emitnx64
    asmx86
    emitnx86
    asmthumb
    emitnthumb
    emitinlinethumb
    asmarm
    emitnarm
    asmxtensa
    emitnxtensa
    emitinlinextensa
    formatfloat
    parsenumbase
    parsenum
    emitglue
    persistentcode
    runtime
    runtime_utils
    scheduler
    nativeglue
    stackctrl
    argcheck
    warning
    map
    obj
    objarray
    objattrtuple
    objbool
    objboundmeth
    objcell
    objclosure
    objcomplex
    objdeque
    objdict
    objenumerate
    objexcept
    objfilter
    objfloat
    objfun
    objgenerator
    objgetitemiter
    objint
    objint_longlong
    objint_mpz
    objlist
    objmap
    objmodule
    objobject
    objpolyiter
    objproperty
    objnone
    objnamedtuple
    objrange
    objreversed
    objset
    objsingleton
    objslice
    objstr
    objstrunicode
    objstringio
    objtuple
    objtype
    objzip
    opmethods
    sequence
    stream
    binary
    builtinimport
    builtinevex
    builtinhelp
    modarray
    modbuiltins
    modcollections
    modgc
    modio
    modmath
    modcmath
    modmicropython
    modstruct
    modsys
    moduerrno
    modthread
    vm
    bc
    showbc
    repl
    smallint
    frozenmod
""")))


env.Replace(PY_EXTMOD_SRCS=
    env.Split("""
    extmod/moductypes
    extmod/modujson
    extmod/modure
    extmod/moduzlib
    extmod/moduheapq
    extmod/modutimeq
    extmod/moduhashlib
    extmod/moducryptolib
    extmod/modubinascii
    extmod/virtpin
    extmod/machine_mem
    extmod/machine_pinbase
    extmod/machine_signal
    extmod/machine_pulse
    extmod/machine_i2c
    extmod/machine_spi
    extmod/modussl_axtls
    extmod/modussl_mbedtls
    extmod/modurandom
    extmod/moduselect
    extmod/modwebsocket
    extmod/modwebrepl
    extmod/modframebuf
    extmod/vfs
    extmod/vfs_reader
    extmod/vfs_posix
    extmod/vfs_posix_file
    extmod/vfs_fat
    extmod/vfs_fat_diskio
    extmod/vfs_fat_file
    extmod/utime_mphal
    extmod/uos_dupterm
    lib/embed/abort_
    lib/utils/printf
"""))

# Setup the builders for PY_CORE_SRCS / PY_EXTMOD_SRCS
# The builders will only be triggered if something depends on the compiled object files

tgts = []
for item in env['PY_CORE_SRCS']:
    loopenv = env
    if item == 'py/gc' or item == 'py/vm':
        loopenv = env.Clone()
        loopenv.MergeFlags('${CSUPEROPT}')
    elif item.startswith('py/nlr'):
        loopenv = env.Clone()
        loopenv.MergeFlags('-Os')
    tgts += loopenv.Object('${BUILD}/' + item, '${TOP}/' + item)
env.Replace(PY_CORE_O=tgts)

tgts = []
for item in env['PY_EXTMOD_SRCS']:
    tgts += env.Object('${BUILD}/' + item, '${TOP}/' + item)
env.Replace(PY_EXTMOD_O=tgts)

# If we want to use gcc's dependency file output for calculating rebuilds
# instead of using scons scanner
if env['SCANDEPFILES']:
    for item in env['PY_EXTMOD_O'] + env['PY_CORE_O']:
        fullpath = item.abspath
        SideEffect(path.basename(fullpath) + '.d', item)
        ParseDepends(path.basename(fullpath) + '.d')


# this is a convenience variable for ports that want core, extmod and frozen code
env.Replace(PY_O=['${PY_CORE_O}', '${PY_EXTMOD_O}'])



# TODO Optional load of mpconfigport.mk script

# TODO
if env['PROG'] != "":
    print("TODO rules for PROG")
    # Rule:    "all"
    # Depends:  ${PROG}

    # Rule:    ${PROG}
    # Depends:  ${OBJ}

    if "DEBUG" not in env:
            print("TODO rules for DEBUG")
            #TODO CONVERSION: statement type: <class 'make2scons.pymake.parserdata.Command'>
    #TODO CONVERSION: statement type: <class 'make2scons.pymake.parserdata.Command'>
    # Rule:    "clean"
    # Depends: " clean-prog"

    # Rule:    "clean-prog"
    # Depends: ""

    # Rule:    ".PHONY"
    # Depends: " clean-prog"

env.Replace(LIBMICROPYTHON='libmicropython.a')
# Rule:    lib ${LIBMICROPYTHON}
# Depends:  ${OBJ}

# Rule:    "clean"
# Depends: ""

# Rule:    ".PHONY"
# Depends: " clean"

# Rule:    "clean-frozen"
# Depends: ""

# Rule:    ".PHONY"
# Depends: " clean-frozen"

# Rule:    "print-cfg"
# Depends: ""

# Rule:    ".PHONY"
# Depends: " print-cfg"
